---
title: Real-time Communication (Socket.IO)
description: Socket.IO implementation for reliable real-time communication
sidebar_position: 9
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';

# Real-time Communication with Socket.IO

## Overview

Archon uses **Socket.IO** for real-time communication between the frontend and backend, replacing traditional WebSockets with a more robust solution. Socket.IO provides automatic reconnection, better connection management, namespace-based organization, and room-based broadcasting - all essential for reliable real-time features.

<Admonition type="info" title="Migration from WebSockets">
Archon has migrated from native WebSockets to Socket.IO for improved reliability and features. The legacy WebSocket endpoints are deprecated and will return an error message directing clients to use Socket.IO.
</Admonition>

## Architecture

```mermaid
graph LR
    subgraph Frontend
        A[React App] --> B[WebSocketService]
        B --> C[Socket.IO Client]
        C --> D[Auto Reconnection]
        C --> E[Namespace Management]
    end
    
    subgraph Backend
        F[Socket.IO Server] --> G[Namespace Handlers]
        G --> H[/crawl Namespace]
        G --> I[/chat Namespace]
        G --> J[/tasks Namespace]
        F --> K[Room Broadcasting]
    end
    
    C -.->|Socket.IO Protocol| F
    
    style A fill:#1a1a2e,stroke:#00d4ff,stroke-width:2px,color:#fff
    style B fill:#1a1a2e,stroke:#00d4ff,stroke-width:2px,color:#fff
    style C fill:#1a1a2e,stroke:#4ecdc4,stroke-width:2px,color:#fff
    style F fill:#1a1a2e,stroke:#4ecdc4,stroke-width:2px,color:#fff
    style G fill:#1a1a2e,stroke:#00d4ff,stroke-width:2px,color:#fff
```

## Frontend Implementation

### Core Socket.IO Service

The `WebSocketService` now uses Socket.IO under the hood, providing all the benefits while maintaining a familiar API:

<Tabs>
<TabItem value="usage" label="Basic Usage">

```typescript
import { createWebSocketService } from './services/webSocketService';

// Create service instance
const wsService = createWebSocketService({
  maxReconnectAttempts: 5,
  reconnectInterval: 1000,
  enableAutoReconnect: true
});

// Connect to endpoint - automatically maps to Socket.IO namespace
await wsService.connect('/api/agent-chat/sessions/123/ws');

// Send messages via Socket.IO events
wsService.send({ type: 'message', content: 'Hello!' });

// Handle incoming messages
wsService.addMessageHandler('message', (msg) => {
  console.log('Received:', msg);
});
```

</TabItem>
<TabItem value="crawl" label="Crawl Progress">

```typescript
import { crawlProgressService } from './services/crawlProgressService';

// Stream crawl progress using Socket.IO
await crawlProgressService.streamProgress(
  progressId,
  (data) => {
    // Handle progress updates
    console.log(`Progress: ${data.percentage}%`);
    console.log(`Status: ${data.status}`);
    
    // Handle worker updates for parallel processing
    if (data.workers) {
      data.workers.forEach(worker => {
        console.log(`Worker ${worker.worker_id}: ${worker.progress}%`);
      });
    }
  },
  {
    autoReconnect: true  // Socket.IO handles this automatically
  }
);
```

</TabItem>
<TabItem value="patterns" label="React Patterns">

```typescript
// Custom hook for Socket.IO connection
function useSocketIO(namespace: string) {
  const [isConnected, setIsConnected] = useState(false);
  const wsRef = useRef<WebSocketService>();
  
  useEffect(() => {
    const ws = createWebSocketService();
    wsRef.current = ws;
    
    ws.addStateChangeHandler((state) => {
      setIsConnected(state === WebSocketState.CONNECTED);
    });
    
    ws.connect(`/api/${namespace}`);
    
    return () => ws.disconnect();
  }, [namespace]);
  
  return { ws: wsRef.current, isConnected };
}
```

</TabItem>
</Tabs>

### Connection States

```typescript
enum WebSocketState {
  CONNECTING = 'CONNECTING',
  CONNECTED = 'CONNECTED',
  RECONNECTING = 'RECONNECTING',  // Socket.IO handles this automatically
  DISCONNECTED = 'DISCONNECTED',
  FAILED = 'FAILED'
}
```

## Socket.IO Features

### Automatic Reconnection

Socket.IO automatically handles reconnection with exponential backoff:

```typescript
const socket = io(url, {
  reconnection: true,
  reconnectionAttempts: 10,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000
});
```

### Namespace-Based Organization

Different features use different Socket.IO namespaces:

```typescript
// Crawl progress namespace
const crawlSocket = io('/crawl');

// Chat namespace  
const chatSocket = io('/chat');

// Task updates namespace
const taskSocket = io('/tasks');
```

### Room-Based Broadcasting

Progress updates are broadcast to specific rooms:

```typescript
// Frontend: Subscribe to progress
socket.emit('subscribe', { progress_id: 'abc123' });

// Backend: Broadcast to room
await sio.emit('progress_update', data, room=progress_id);
```

## Backend Implementation

### Socket.IO Server Setup

<Tabs>
<TabItem value="setup" label="Server Setup">

```python
# socketio_app.py
import socketio
from fastapi import FastAPI

# Create Socket.IO server
sio = socketio.AsyncServer(
    async_mode='asgi',
    cors_allowed_origins="*",
    ping_timeout=60,
    ping_interval=25
)

def create_socketio_app(app: FastAPI):
    """Wrap FastAPI with Socket.IO"""
    return socketio.ASGIApp(sio, app)
```

</TabItem>
<TabItem value="namespace" label="Namespace Handler">

```python
# Crawl namespace handler
@sio.on('connect', namespace='/crawl')
async def on_crawl_connect(sid, environ):
    """Handle client connections to crawl namespace"""
    print(f"Client {sid} connected to /crawl")
    await sio.emit('connected', 
                   {'message': 'Connected to crawl progress'}, 
                   to=sid, namespace='/crawl')

@sio.on('subscribe', namespace='/crawl')
async def on_subscribe(sid, data):
    """Subscribe to progress updates"""
    progress_id = data.get('progress_id')
    
    # Join room for this progress ID
    await sio.enter_room(sid, progress_id, namespace='/crawl')
    
    # Send current progress if available
    if progress_id in active_crawls:
        await sio.emit('progress_update', 
                      active_crawls[progress_id], 
                      to=sid, namespace='/crawl')
```

</TabItem>
<TabItem value="broadcast" label="Broadcasting">

```python
class CrawlProgressManagerSocketIO:
    """Socket.IO-based progress manager"""
    
    async def update_progress(self, progress_id: str, data: dict):
        """Update progress and notify clients via Socket.IO"""
        self.active_crawls[progress_id].update(data)
        
        # Broadcast to all clients in the room
        await self.sio.emit(
            'progress_update',
            self._prepare_progress_data(progress_id),
            room=progress_id,
            namespace='/crawl'
        )
    
    async def _broadcast_worker_progress(self, progress_id: str, 
                                       worker_id: str, data: dict):
        """Broadcast worker-specific progress"""
        await self.sio.emit(
            'worker_progress',
            {
                'progress_id': progress_id,
                'worker_id': worker_id,
                **data
            },
            room=progress_id,
            namespace='/crawl'
        )
```

</TabItem>
</Tabs>

## Migration from WebSockets

### Feature Flag

The backend supports a feature flag for gradual migration:

```python
# Enable Socket.IO (default: true)
USE_SOCKETIO_PROGRESS = os.getenv("USE_SOCKETIO_PROGRESS", "true").lower() == "true"

if USE_SOCKETIO_PROGRESS:
    from .crawl_progress_manager_socketio import progress_manager
else:
    # Legacy WebSocket implementation
    progress_manager = CrawlProgressManager()
```

### Deprecated WebSocket Endpoint

The legacy WebSocket endpoint now returns a deprecation message:

```python
@router.websocket("/crawl-progress/{progress_id}")
async def websocket_crawl_progress(websocket: WebSocket, progress_id: str):
    if USE_SOCKETIO_PROGRESS:
        await websocket.accept()
        await websocket.send_json({
            "type": "error",
            "message": "WebSocket endpoint deprecated. Please use Socket.IO connection on /crawl namespace."
        })
        await websocket.close()
        return
```

## Best Practices

<Admonition type="tip" title="Socket.IO Best Practices">
1. **Use namespaces** to organize different features
2. **Use rooms** for targeted broadcasting
3. **Let Socket.IO handle reconnection** - don't implement custom logic
4. **Send acknowledgments** for critical messages
5. **Use event names** that clearly describe the action
</Admonition>

### Event Naming Conventions

```typescript
// Good event names
socket.emit('progress_update', data);
socket.emit('task_completed', data);
socket.emit('worker_status', data);

// Avoid generic names
socket.emit('message', data);  // Too generic
socket.emit('data', data);     // Unclear purpose
```

### Error Handling

```typescript
// Socket.IO provides built-in error handling
socket.on('connect_error', (error) => {
  console.error('Connection error:', error);
  showToast('Connection error. Retrying...', 'error');
});

socket.on('reconnect_failed', () => {
  console.error('Failed to reconnect after maximum attempts');
  showToast('Connection lost. Please refresh the page.', 'error');
});
```

### Memory Management

<Admonition type="warning" title="Prevent Memory Leaks">
Always clean up Socket.IO listeners in React cleanup functions:

```typescript
useEffect(() => {
  const socket = io('/namespace');
  
  socket.on('event', handler);
  
  return () => {
    socket.off('event', handler);
    socket.disconnect();
  };
}, []);
```
</Admonition>

## Common Patterns

### Progress Tracking with Workers

```typescript
// Handle parallel worker progress
socket.on('progress_update', (data) => {
  // Overall progress
  setProgress({
    percentage: data.percentage,
    status: data.status,
    logs: data.logs
  });
  
  // Worker-specific progress
  if (data.workers) {
    setWorkers(data.workers.map(worker => ({
      id: worker.worker_id,
      status: worker.status,
      progress: worker.progress,
      message: worker.message
    })));
  }
});
```

### Real-time Chat

```typescript
// Join chat session
socket.emit('join_session', { session_id });

// Send message
socket.emit('message', {
  content: text,
  timestamp: new Date().toISOString()
});

// Receive messages
socket.on('message', (msg) => {
  addChatMessage(msg);
});

// Typing indicators
socket.emit('typing', { is_typing: true });
socket.on('typing', (data) => {
  setTypingUsers(data.users);
});
```

### Task Updates

```typescript
// Subscribe to task updates
socket.emit('subscribe_tasks', { project_id });

// Receive task updates
socket.on('task_created', (task) => {
  addTask(task);
});

socket.on('task_updated', (task) => {
  updateTask(task.id, task);
});

socket.on('task_status_changed', (data) => {
  updateTaskStatus(data.task_id, data.new_status);
});
```

## Performance Monitoring

```typescript
// Monitor Socket.IO connection health
const connectionMonitor = {
  reconnectAttempts: 0,
  lastDisconnect: null,
  
  init: (socket) => {
    socket.on('reconnect_attempt', (attempt) => {
      console.log(`Reconnect attempt ${attempt}`);
      connectionMonitor.reconnectAttempts = attempt;
    });
    
    socket.on('reconnect', () => {
      console.log('Reconnected successfully');
      connectionMonitor.reconnectAttempts = 0;
    });
    
    socket.on('disconnect', (reason) => {
      console.log(`Disconnected: ${reason}`);
      connectionMonitor.lastDisconnect = new Date();
    });
  }
};
```

## Testing Socket.IO

<Admonition type="info" title="Testing Strategy">
Mock Socket.IO connections in tests:

```typescript
// Mock Socket.IO for testing
vi.mock('socket.io-client', () => ({
  io: vi.fn(() => ({
    connect: vi.fn(),
    disconnect: vi.fn(),
    emit: vi.fn(),
    on: vi.fn(),
    off: vi.fn(),
    connected: true
  }))
}));

// Test example
it('should handle progress updates', () => {
  const mockSocket = io();
  const onProgress = vi.fn();
  
  // Simulate progress update
  mockSocket.on.mockImplementation((event, handler) => {
    if (event === 'progress_update') {
      handler({ percentage: 50, status: 'processing' });
    }
  });
  
  expect(onProgress).toHaveBeenCalledWith({
    percentage: 50,
    status: 'processing'
  });
});
```
</Admonition>

## Troubleshooting

<Tabs>
<TabItem value="connection" label="Connection Issues">

**Problem**: Socket.IO fails to connect

```typescript
// Check connection status
console.log('Socket connected:', socket.connected);
console.log('Socket ID:', socket.id);

// Force reconnection
socket.connect();

// Check transport type
socket.on('connect', () => {
  console.log('Transport:', socket.io.engine.transport.name);
});
```

</TabItem>
<TabItem value="docker" label="Docker Configuration">

**Problem**: Socket.IO connection fails in Docker

Ensure the frontend proxy configuration includes WebSocket upgrade:

```typescript
// vite.config.ts
proxy: {
  '/socket.io': {
    target: 'http://archon-api:8080',
    ws: true,
    changeOrigin: true
  }
}
```

</TabItem>
<TabItem value="events" label="Missing Events">

**Problem**: Not receiving Socket.IO events

```typescript
// Debug all incoming events
socket.onAny((eventName, ...args) => {
  console.log(`Received event: ${eventName}`, args);
});

// Check if joined correct room/namespace
socket.on('connect', () => {
  console.log('Connected to namespace:', socket.nsp);
});
```

</TabItem>
</Tabs>

## Additional Resources

- [Socket.IO Documentation](https://socket.io/docs/v4/)
- [Socket.IO Client API](https://socket.io/docs/v4/client-api/)
- [Socket.IO Server API](https://socket.io/docs/v4/server-api/)
- [python-socketio Documentation](https://python-socketio.readthedocs.io/)