---
title: Real-time Communication (Socket.IO)
description: Socket.IO implementation for reliable real-time communication
sidebar_position: 9
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';

# Real-time Communication with Socket.IO

## Overview

Archon uses **Socket.IO** for real-time communication between the frontend and backend, replacing traditional WebSockets with a more robust solution. Socket.IO provides automatic reconnection, better connection management, namespace-based organization, and room-based broadcasting - all essential for reliable real-time features.

<Admonition type="info" title="Migration from WebSockets">
Archon has migrated from native WebSockets to Socket.IO for improved reliability and features. The legacy WebSocket endpoints are deprecated and will return an error message directing clients to use Socket.IO.
</Admonition>

## Available Namespaces

Archon implements Socket.IO communication through dedicated namespaces:

| Namespace | Purpose | Primary Events |
|-----------|---------|----------------|
| `/` | Default namespace | `connect`, `disconnect`, `ping/pong` |
| `/crawl` | Crawling progress | `subscribe`, `progress_update`, `worker_progress` |
| `/chat` | Agent chat sessions | `join_session`, `message`, `typing` |
| `/tasks` | Task updates | `task_created`, `task_updated`, `task_status_changed` |
| `/project` | Project updates | `project_progress`, `project_completed` |
| `/knowledge` | Knowledge base updates | `source_added`, `source_updated` |
| `/logs` | Log streaming | `log_entry`, `log_batch` |
| `/tests` | Test execution | `test_progress`, `test_result` |

## Architecture

```mermaid
graph LR
    subgraph Frontend
        A[React App] --> B[WebSocketService]
        B --> C[Socket.IO Client]
        C --> D[Auto Reconnection]
        C --> E[Namespace Management]
    end
    
    subgraph Backend
        F[Socket.IO Server] --> G[Namespace Handlers]
        G --> H[/crawl Namespace]
        G --> I[/chat Namespace]
        G --> J[/tasks Namespace]
        F --> K[Room Broadcasting]
    end
    
    C -.->|Socket.IO Protocol| F
    
    style A fill:#1a1a2e,stroke:#00d4ff,stroke-width:2px,color:#fff
    style B fill:#1a1a2e,stroke:#00d4ff,stroke-width:2px,color:#fff
    style C fill:#1a1a2e,stroke:#4ecdc4,stroke-width:2px,color:#fff
    style F fill:#1a1a2e,stroke:#4ecdc4,stroke-width:2px,color:#fff
    style G fill:#1a1a2e,stroke:#00d4ff,stroke-width:2px,color:#fff
```

## Frontend Implementation

### Core Socket.IO Service

The `WebSocketService` now uses Socket.IO under the hood, providing all the benefits while maintaining a familiar API:

<Tabs>
<TabItem value="usage" label="Basic Usage">

```typescript
import { createWebSocketService } from './services/webSocketService';

// Create service instance
const wsService = createWebSocketService({
  maxReconnectAttempts: 5,
  reconnectInterval: 1000,
  enableAutoReconnect: true
});

// Connect to endpoint - automatically maps to Socket.IO namespace
await wsService.connect('/api/agent-chat/sessions/123/ws');

// Send messages via Socket.IO events
wsService.send({ type: 'message', content: 'Hello!' });

// Handle incoming messages
wsService.addMessageHandler('message', (msg) => {
  console.log('Received:', msg);
});
```

</TabItem>
<TabItem value="crawl" label="Crawl Progress">

```typescript
import { crawlProgressService } from './services/crawlProgressService';

// Stream crawl progress using Socket.IO
await crawlProgressService.streamProgress(
  progressId,
  (data) => {
    // Handle progress updates
    console.log(`Progress: ${data.percentage}%`);
    console.log(`Status: ${data.status}`);
    
    // Handle worker updates for parallel processing
    if (data.workers) {
      data.workers.forEach(worker => {
        console.log(`Worker ${worker.worker_id}: ${worker.progress}%`);
      });
    }
  },
  {
    autoReconnect: true  // Socket.IO handles this automatically
  }
);
```

</TabItem>
<TabItem value="patterns" label="React Patterns">

```typescript
// Custom hook for Socket.IO connection
function useSocketIO(namespace: string) {
  const [isConnected, setIsConnected] = useState(false);
  const wsRef = useRef<WebSocketService>();
  
  useEffect(() => {
    const ws = createWebSocketService();
    wsRef.current = ws;
    
    ws.addStateChangeHandler((state) => {
      setIsConnected(state === WebSocketState.CONNECTED);
    });
    
    ws.connect(`/api/${namespace}`);
    
    return () => ws.disconnect();
  }, [namespace]);
  
  return { ws: wsRef.current, isConnected };
}
```

</TabItem>
</Tabs>

### Connection States

```typescript
enum WebSocketState {
  CONNECTING = 'CONNECTING',
  CONNECTED = 'CONNECTED',
  RECONNECTING = 'RECONNECTING',  // Socket.IO handles this automatically
  DISCONNECTED = 'DISCONNECTED',
  FAILED = 'FAILED'
}
```

## Socket.IO Features

### Automatic Reconnection

Socket.IO automatically handles reconnection with exponential backoff:

```typescript
const socket = io(url, {
  reconnection: true,
  reconnectionAttempts: 10,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000
});
```

### Namespace-Based Organization

Different features use different Socket.IO namespaces:

```typescript
// Crawl progress namespace
const crawlSocket = io('/crawl');

// Chat namespace  
const chatSocket = io('/chat');

// Task updates namespace
const taskSocket = io('/tasks');
```

### Room-Based Broadcasting

Progress updates are broadcast to specific rooms:

```typescript
// Frontend: Subscribe to progress
socket.emit('subscribe', { progress_id: 'abc123' });

// Backend: Broadcast to room
await sio.emit('progress_update', data, room=progress_id);
```

## Backend Implementation

### Socket.IO Server Setup

The Socket.IO server is configured in `socketio_app.py` with optimized settings for production:

<Tabs>
<TabItem value="setup" label="Server Setup">

```python
# socketio_app.py
import socketio
from fastapi import FastAPI

# Create Socket.IO server with optimized settings
sio = socketio.AsyncServer(
    async_mode='asgi',
    cors_allowed_origins="*",  # Configure for production
    logger=False,  # Disable verbose logging
    engineio_logger=False,
    # Performance settings
    max_http_buffer_size=1000000,  # 1MB
    ping_timeout=60,
    ping_interval=25
)

def create_socketio_app(app: FastAPI):
    """Wrap FastAPI with Socket.IO"""
    socket_app = socketio.ASGIApp(sio, other_asgi_app=app)
    return socket_app
```

</TabItem>
<TabItem value="namespace" label="Namespace Handlers">

```python
# Default namespace handlers
@sio.event
async def connect(sid, environ):
    """Handle new Socket.IO connections"""
    client_address = environ.get('REMOTE_ADDR', 'unknown')
    logfire.info("Socket.IO client connected", 
                 session_id=sid, 
                 client_address=client_address)
    await sio.emit('connected', {'sid': sid}, to=sid)

@sio.event
async def disconnect(sid):
    """Handle Socket.IO disconnections"""
    logfire.info("Socket.IO client disconnected", session_id=sid)

@sio.event
async def ping(sid):
    """Handle ping messages for connection health checks"""
    await sio.emit('pong', to=sid)

# Crawl namespace handlers
@sio.on('connect', namespace='/crawl')
async def on_crawl_connect(sid, environ):
    """Handle client connections to crawl namespace"""
    await sio.emit('connected', 
                   {'message': 'Connected to crawl progress'}, 
                   to=sid, namespace='/crawl')

@sio.on('subscribe', namespace='/crawl')
async def on_subscribe_progress(sid, data):
    """Subscribe to crawl progress updates"""
    progress_id = data.get('progress_id')
    if not progress_id:
        await sio.emit('error', 
                      {'message': 'progress_id required'}, 
                      to=sid, namespace='/crawl')
        return
    
    # Join the room for this progress ID
    await sio.enter_room(sid, progress_id, namespace='/crawl')

@sio.on('unsubscribe', namespace='/crawl')
async def on_unsubscribe_progress(sid, data):
    """Unsubscribe from crawl progress updates"""
    progress_id = data.get('progress_id')
    if progress_id:
        await sio.leave_room(sid, progress_id, namespace='/crawl')
```

</TabItem>
<TabItem value="broadcast" label="Broadcasting">

```python
class CrawlProgressManagerSocketIO:
    """Socket.IO-based progress manager"""
    
    async def update_progress(self, progress_id: str, data: dict):
        """Update progress and notify clients via Socket.IO"""
        self.active_crawls[progress_id].update(data)
        
        # Broadcast to all clients in the room
        await self.sio.emit(
            'progress_update',
            self._prepare_progress_data(progress_id),
            room=progress_id,
            namespace='/crawl'
        )
    
    async def _broadcast_worker_progress(self, progress_id: str, 
                                       worker_id: str, data: dict):
        """Broadcast worker-specific progress"""
        await self.sio.emit(
            'worker_progress',
            {
                'progress_id': progress_id,
                'worker_id': worker_id,
                **data
            },
            room=progress_id,
            namespace='/crawl'
        )
```

</TabItem>
</Tabs>

## Migration from WebSockets

### Feature Flag

The backend supports a feature flag for gradual migration:

```python
# Enable Socket.IO (default: true)
USE_SOCKETIO_PROGRESS = os.getenv("USE_SOCKETIO_PROGRESS", "true").lower() == "true"

if USE_SOCKETIO_PROGRESS:
    from .crawl_progress_manager_socketio import progress_manager
else:
    # Legacy WebSocket implementation
    progress_manager = CrawlProgressManager()
```

### Deprecated WebSocket Endpoint

The legacy WebSocket endpoint now returns a deprecation message:

```python
@router.websocket("/crawl-progress/{progress_id}")
async def websocket_crawl_progress(websocket: WebSocket, progress_id: str):
    if USE_SOCKETIO_PROGRESS:
        await websocket.accept()
        await websocket.send_json({
            "type": "error",
            "message": "WebSocket endpoint deprecated. Please use Socket.IO connection on /crawl namespace."
        })
        await websocket.close()
        return
```

## Best Practices

<Admonition type="tip" title="Socket.IO Best Practices">
1. **Use namespaces** to organize different features
2. **Use rooms** for targeted broadcasting
3. **Let Socket.IO handle reconnection** - don't implement custom logic
4. **Send acknowledgments** for critical messages
5. **Use event names** that clearly describe the action
</Admonition>

### Event Naming Conventions

```typescript
// Good event names - clear and specific
socket.emit('progress_update', data);
socket.emit('task_completed', data);
socket.emit('worker_status', data);
socket.emit('source_added', data);

// Avoid generic names
socket.emit('message', data);  // Too generic
socket.emit('data', data);     // Unclear purpose
socket.emit('update', data);   // Not descriptive
```

## Complete Event Reference

### Default Namespace (`/`)

| Event | Direction | Description | Data Format |
|-------|-----------|-------------|-------------|
| `connect` | Server→Client | Connection established | `{sid: string}` |
| `disconnect` | Server→Client | Connection closed | None |
| `ping` | Client→Server | Health check | None |
| `pong` | Server→Client | Health response | None |
| `connected` | Server→Client | Acknowledgment | `{sid: string}` |

### Crawl Namespace (`/crawl`)

| Event | Direction | Description | Data Format |
|-------|-----------|-------------|-------------|
| `subscribe` | Client→Server | Subscribe to progress | `{progress_id: string}` |
| `unsubscribe` | Client→Server | Unsubscribe from progress | `{progress_id: string}` |
| `progress_update` | Server→Client | Progress update | `{progressId, status, percentage, logs, ...}` |
| `worker_progress` | Server→Client | Worker-specific update | `{progress_id, worker_id, status, ...}` |
| `crawl_completed` | Server→Client | Crawl finished | `{progressId, chunksStored, wordCount}` |
| `crawl_error` | Server→Client | Crawl failed | `{progressId, error}` |

### Task Namespace (`/tasks`)

| Event | Direction | Description | Data Format |
|-------|-----------|-------------|-------------|
| `task_created` | Server→Client | New task created | Full task object |
| `task_updated` | Server→Client | Task modified | Full task object |
| `task_deleted` | Server→Client | Task removed | `{task_id: string}` |
| `task_status_changed` | Server→Client | Status update | `{task_id, old_status, new_status}` |
| `task_batch_update` | Server→Client | Multiple tasks updated | Array of task objects |

### Project Namespace (`/project`)

| Event | Direction | Description | Data Format |
|-------|-----------|-------------|-------------|
| `project_progress` | Server→Client | Creation progress | `{progressId, status, step, percentage}` |
| `project_completed` | Server→Client | Project created | `{progressId, project_id, success}` |
| `project_error` | Server→Client | Creation failed | `{progressId, error}` |
| `project_updated` | Server→Client | Project modified | Full project object |

### Error Handling

```typescript
// Socket.IO provides built-in error handling
socket.on('connect_error', (error) => {
  console.error('Connection error:', error);
  showToast('Connection error. Retrying...', 'error');
});

socket.on('reconnect_failed', () => {
  console.error('Failed to reconnect after maximum attempts');
  showToast('Connection lost. Please refresh the page.', 'error');
});
```

### Memory Management

<Admonition type="warning" title="Prevent Memory Leaks">
Always clean up Socket.IO listeners in React cleanup functions:

```typescript
useEffect(() => {
  const socket = io('/namespace');
  
  socket.on('event', handler);
  
  return () => {
    socket.off('event', handler);
    socket.disconnect();
  };
}, []);
```
</Admonition>

## Common Patterns

### Progress Tracking with Workers

```typescript
// Subscribe to specific progress
socket.emit('subscribe', { progress_id: progressId });

// Handle overall progress updates
socket.on('progress_update', (data) => {
  setProgress({
    percentage: data.percentage,
    status: data.status,
    logs: data.logs,
    currentUrl: data.currentUrl,
    totalPages: data.totalPages,
    processedPages: data.processedPages
  });
});

// Handle worker-specific updates
socket.on('worker_progress', (data) => {
  updateWorker(data.worker_id, {
    status: data.status,
    progress: data.progress,
    message: data.message,
    current_item: data.current_item
  });
});

// Handle completion
socket.on('crawl_completed', (data) => {
  console.log(`Crawl completed: ${data.chunksStored} chunks stored`);
  // Unsubscribe when done
  socket.emit('unsubscribe', { progress_id: data.progressId });
});
```

### Real-time Chat

```typescript
// Join chat session
socket.emit('join_session', { session_id });

// Send message
socket.emit('message', {
  content: text,
  timestamp: new Date().toISOString()
});

// Receive messages
socket.on('message', (msg) => {
  addChatMessage(msg);
});

// Typing indicators
socket.emit('typing', { is_typing: true });
socket.on('typing', (data) => {
  setTypingUsers(data.users);
});
```

### Task Updates

```typescript
// Join project room for task updates
const taskSocket = io('/tasks');

// Listen for task events
taskSocket.on('task_created', (task) => {
  addTask(task);
  showToast(`New task: ${task.title}`, 'info');
});

taskSocket.on('task_updated', (task) => {
  updateTask(task.id, task);
});

taskSocket.on('task_status_changed', (data) => {
  updateTaskStatus(data.task_id, data.new_status);
  if (data.new_status === 'done') {
    showToast(`Task completed: ${data.task_title}`, 'success');
  }
});

taskSocket.on('task_batch_update', (tasks) => {
  // Handle multiple task updates efficiently
  tasks.forEach(task => updateTask(task.id, task));
});
```

### Project Creation Progress

```typescript
// Monitor project creation
const projectSocket = io('/project');

projectSocket.on('project_progress', (data) => {
  updateProgress({
    step: data.step,
    percentage: data.percentage,
    message: data.log
  });
});

projectSocket.on('project_completed', (data) => {
  if (data.success) {
    navigateToProject(data.project_id);
  }
});

projectSocket.on('project_error', (data) => {
  showError(`Project creation failed: ${data.error}`);
});
```

## Performance Monitoring

```typescript
// Monitor Socket.IO connection health
const connectionMonitor = {
  reconnectAttempts: 0,
  lastDisconnect: null,
  
  init: (socket) => {
    socket.on('reconnect_attempt', (attempt) => {
      console.log(`Reconnect attempt ${attempt}`);
      connectionMonitor.reconnectAttempts = attempt;
    });
    
    socket.on('reconnect', () => {
      console.log('Reconnected successfully');
      connectionMonitor.reconnectAttempts = 0;
    });
    
    socket.on('disconnect', (reason) => {
      console.log(`Disconnected: ${reason}`);
      connectionMonitor.lastDisconnect = new Date();
    });
  }
};
```

## Testing Socket.IO

<Admonition type="info" title="Testing Strategy">
Mock Socket.IO connections in tests:

```typescript
// Mock Socket.IO for testing
vi.mock('socket.io-client', () => ({
  io: vi.fn(() => ({
    connect: vi.fn(),
    disconnect: vi.fn(),
    emit: vi.fn(),
    on: vi.fn(),
    off: vi.fn(),
    connected: true
  }))
}));

// Test example
it('should handle progress updates', () => {
  const mockSocket = io();
  const onProgress = vi.fn();
  
  // Simulate progress update
  mockSocket.on.mockImplementation((event, handler) => {
    if (event === 'progress_update') {
      handler({ percentage: 50, status: 'processing' });
    }
  });
  
  expect(onProgress).toHaveBeenCalledWith({
    percentage: 50,
    status: 'processing'
  });
});
```
</Admonition>

## Troubleshooting

<Tabs>
<TabItem value="connection" label="Connection Issues">

**Problem**: Socket.IO fails to connect

```typescript
// Check connection status
console.log('Socket connected:', socket.connected);
console.log('Socket ID:', socket.id);

// Force reconnection
socket.connect();

// Check transport type
socket.on('connect', () => {
  console.log('Transport:', socket.io.engine.transport.name);
});
```

</TabItem>
<TabItem value="docker" label="Docker Configuration">

**Problem**: Socket.IO connection fails in Docker

Ensure the frontend proxy configuration includes WebSocket upgrade:

```typescript
// vite.config.ts
proxy: {
  '/socket.io': {
    target: 'http://archon-api:8080',
    ws: true,
    changeOrigin: true
  }
}
```

</TabItem>
<TabItem value="events" label="Missing Events">

**Problem**: Not receiving Socket.IO events

```typescript
// Debug all incoming events
socket.onAny((eventName, ...args) => {
  console.log(`Received event: ${eventName}`, args);
});

// Check if joined correct room/namespace
socket.on('connect', () => {
  console.log('Connected to namespace:', socket.nsp);
});
```

</TabItem>
</Tabs>

## Additional Resources

- [Socket.IO Documentation](https://socket.io/docs/v4/)
- [Socket.IO Client API](https://socket.io/docs/v4/client-api/)
- [Socket.IO Server API](https://socket.io/docs/v4/server-api/)
- [python-socketio Documentation](https://python-socketio.readthedocs.io/)